# このコードは、2状態（L1, L2）の価値関数 V(s) を
# ベルマン期待更新（Bellman expectation update）で反復計算し、
# 収束したら停止する例です。
#
# 直前に出てきた「new_V を使う同期更新（synchronous update）」版と違い、
# こちらは V をその場で書き換えながら更新する「非同期更新（asynchronous update）」
# になっています。特にこの順番は、L1 を更新した直後の新しい V(L1) を使って
# L2 を更新するため、数値解析の言い方ではガウス＝ザイデル法（Gauss–Seidel）
# に近い挙動になります。
#
# 重要ポイント：
# - 同期更新：V_{k+1}(s) を全部 V_k から計算して最後に一括置換（new_V を使う）
# - 非同期更新：更新した V(s) を即座に次の計算に使う（このコード）
#
# 多くの場合、ガウス＝ザイデル型の非同期更新は同期更新より収束が速くなることがあります。
# （ただし一般のMDPや更新順序によって挙動が変わるので、常に速いとは限りません）

# -------------------------
# 価値関数の初期化
# -------------------------
# V は現在の価値推定値 V(s) を保持する辞書。
# 初期値は 0 に設定（よくある初期化）。
V = {"L1": 0.0, "L2": 0.0}

# 反復回数カウンタ
cnt = 0

# -------------------------
# 反復方策評価（非同期 / ガウス＝ザイデル型）
# -------------------------
while True:
    # ここでの更新は「固定方策 π の下でのベルマン期待方程式」の右辺を計算している。
    # discount factor（割引率）γ = 0.9

    # =========================================================
    # 1) L1 の更新
    # =========================================================
    # L1 におけるベルマン期待更新（2分岐を0.5ずつ混合）：
    #
    #   V_{new}(L1) = 0.5 * (-1 + γ V(L1)) + 0.5 * ( 1 + γ V(L2))
    #
    # これは「方策が2つの行動（または2つの遷移）を等確率で選ぶ」とみなせる。
    # - 分岐A：即時報酬 -1、次状態 L1
    # - 分岐B：即時報酬 +1、次状態 L2
    t = 0.5 * (-1 + 0.9 * V["L1"]) + 0.5 * (1 + 0.9 * V["L2"])

    # 収束判定用：更新前後の差 |t - V(L1)|
    # ここでは一旦 delta を L1 の差分で初期化している。
    delta = abs(t - V["L1"])

    # 非同期更新：L1 をその場で更新する
    # ここで V['L1'] は「新しい値」になり、次の L2 更新で即座に利用される。
    V["L1"] = t

    # =========================================================
    # 2) L2 の更新
    # =========================================================
    # L2 におけるベルマン期待更新（2分岐を0.5ずつ混合）：
    #
    #   V_{new}(L2) = 0.5 * ( 0 + γ V(L1)) + 0.5 * (-1 + γ V(L2))
    #
    # - 分岐A：即時報酬 0、次状態 L1
    # - 分岐B：即時報酬 -1、次状態 L2
    #
    # 注意：
    # ここで使われる V['L1'] は、直前に更新済みの「新しい V(L1)」である。
    # したがって、この反復は
    #   V_{k+1}(L2) を計算するときに V_{k+1}(L1) を使う
    # というガウス＝ザイデル型の更新順序になっている。
    t = 0.5 * (0 + 0.9 * V["L1"]) + 0.5 * (-1 + 0.9 * V["L2"])

    # delta は「全状態での最大更新量」max_s |V_new(s) - V_old(s)| を見たいので、
    # L2 の差分も計算して max を取る。
    delta = max(delta, abs(t - V["L2"]))

    # 非同期更新：L2 もその場で更新する
    V["L2"] = t

    # 反復回数を増やす
    cnt += 1

    # =========================================================
    # 収束判定
    # =========================================================
    # delta が十分小さければ、ベルマン期待方程式の固定点に近づいたとみなして停止する。
    # γ < 1 の場合、ベルマン期待オペレータは収縮写像になりやすく、
    # 固定点（= 方策 π の下での真の価値 V^π）へ収束することが期待される。
    if delta < 0.0001:
        print(V)  # 収束した価値推定
        print(cnt)  # 収束までの反復回数
        break
